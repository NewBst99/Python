{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 273,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "세대 번호 =  0\n",
      "경로 # 0 = ['A', 'B', 'D', 'C'] 거리 =  80\n",
      "경로 # 1 = ['B', 'C', 'D', 'A'] 거리 =  95\n",
      "경로 # 2 = ['A', 'D', 'C', 'B'] 거리 =  95\n",
      "경로 # 3 = ['D', 'C', 'B', 'A'] 거리 =  95\n",
      "\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "\n",
    "POPULATION_SIZE = 4  \n",
    "MUTATION_RATE = 0     # 돌연 변이 확률\n",
    "CITY_SIZE = 4    # 하나의 염색체에서 유전자 개수\n",
    "\n",
    "# 염색체를 클래스로 정의한다. \n",
    "class Chromosome:\n",
    "    def __init__(self, c = []):   # c는 경로 리스트\n",
    "        self.city = c.copy()   # 경로는 리스트로 구현\n",
    "        self.total = 0 # 거리\n",
    "        if self.city.__len__() == 0:     # 경로가 초기 상태면 초기화\n",
    "            i = 0       # 경로 리스트 비어있으면 초기화\n",
    "            for i in range(CITY_SIZE):\n",
    "                num = random.randint(0, CITY_SIZE - 1)\n",
    "                while(num in self.city):\n",
    "                    num = random.randint(0, CITY_SIZE - 1)\n",
    "                self.city.append(num)\n",
    "\n",
    "    # 거리 계산\n",
    "    def cal_distance(self):\n",
    "        self.total = 0;\n",
    "        distance = 0;\n",
    "        for i in range(CITY_SIZE - 1):\n",
    "            current = self.city[i]\n",
    "            next = self.city[i + 1]\n",
    "            distance += info[current][next]\n",
    "        distance += info[self.city[CITY_SIZE - 1]][self.city[0]]\n",
    "        self.total = distance\n",
    "        return self.total\n",
    "    \n",
    "    # 경로 리스트를 문자열로 반환\n",
    "    def __str__(self):\n",
    "        tran_path = [tran_city[c] for c in self.city]\n",
    "        return tran_path.__str__()\n",
    "    \n",
    "# 도시와 거리 출력 \n",
    "def print_p(pop):\n",
    "    i = 0\n",
    "    for x in pop:       # pop 리스트에 있는 도시에 대해 반복\n",
    "        print(\"경로 #\", i, \"=\", x, \"거리 = \", x.cal_distance())\n",
    "        i += 1\n",
    "    print(\"\")\n",
    "\n",
    "# 선택 연산\n",
    "def select(pop):\n",
    "    short_distance = sum([c.cal_distance() for c in population])      # 전체 적합도 계산\n",
    "    pick = random.uniform(0, short_distance)\n",
    "    current = 0\n",
    "\n",
    "    # 룰렛휠에서 어떤 조각에 속하는지를 알아내는 루프\n",
    "    for c in pop:\n",
    "        current += c.cal_distance()\n",
    "        if current >= pick:\n",
    "            return c    # 현재 염색체 반환\n",
    "\n",
    "# 교차 연산\n",
    "def crossover(pop):\n",
    "    child1, child2 = [], []\n",
    "    father = select(pop)\n",
    "    mother = select(pop)\n",
    "    index = random.randint(1, CITY_SIZE - 1)    # 교차지점 무작위 선택\n",
    "    # child1 += father[:index]\n",
    "    # child2 += mother[:index]\n",
    "    \n",
    "    for city in mother.city:\n",
    "        if(city not in father.city[:index]):\n",
    "            child1.append(city)\n",
    "    child1 += father.city[:index]\n",
    "    \n",
    "    for city in father.city:\n",
    "        if(city not in mother.city[:index]):\n",
    "            child2.append(city)\n",
    "    child2 += mother.city[:index]\n",
    "   \n",
    "    return (child1, child2)\n",
    "\n",
    "# 돌연변이 연산\n",
    "def mutate(c):\n",
    "    for i in range(CITY_SIZE):\n",
    "        if random.random() < MUTATION_RATE:\n",
    "            if random.random() < 0.5:\n",
    "                c.city[i] = random.randint(0, CITY_SIZE - 1)\n",
    "\n",
    "# 메인 프로그램\n",
    "info = [[0, 10, 15, 20],\n",
    "        [10, 0, 35, 25],\n",
    "        [15, 35, 0, 30],\n",
    "        [20, 25, 30, 0]]\n",
    "tran_city = {0:\"A\", 1:\"B\", 2:\"C\", 3:\"D\"}\n",
    "population = []\n",
    "i = 0\n",
    "\n",
    "# 초기 경로를 생성하여 객체 집단에 추가한다. \n",
    "while i < CITY_SIZE:\n",
    "    population.append(Chromosome())\n",
    "    i += 1\n",
    "\n",
    "count = 0\n",
    "population.sort(key=lambda x: x.cal_distance(), reverse=False)\n",
    "print(\"세대 번호 = \", count)\n",
    "print_p(population)\n",
    "count = 1\n",
    "if population[0].cal_distance() != 80:\n",
    "    while count < 100:\n",
    "        new_pop = []\n",
    "        # 선택과 교차 연산\n",
    "        for _ in range(CITY_SIZE // 2):\n",
    "            c1, c2 = crossover(population);\n",
    "            new_pop.append(Chromosome(c1));\n",
    "            new_pop.append(Chromosome(c2));\n",
    "        \n",
    "        # 자식 세대가 부모 세대를 대체한다. \n",
    "        # 깊은 복사를 수행한다. \n",
    "        population = new_pop.copy(); \n",
    "\n",
    "        # 돌연변이 연산\n",
    "        for c in population: mutate(c)\n",
    "        \n",
    "        # 출력을 위한 정렬\n",
    "        population.sort(key=lambda x: x.cal_distance(), reverse=False)\n",
    "        print(\"세대 번호 = \", count)\n",
    "        print_p(population)\n",
    "        count += 1\n",
    "        \n",
    "        if population[0].cal_distance() == 80:\n",
    "            break;"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
